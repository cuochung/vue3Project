{
  "version": 3,
  "sources": ["../../vuetify/src/composables/filter.tsx"],
  "sourcesContent": ["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { computed, shallowRef, unref, watchEffect } from 'vue'\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\n\n/**\n * - boolean: match without highlight\n * - number: single match (index), length already known\n * - []: single match (start, end)\n * - [][]: multiple matches (start, end), shouldn't overlap\n */\nexport type FilterMatchArraySingle = readonly [number, number]\nexport type FilterMatchArrayMultiple = readonly FilterMatchArraySingle[]\nexport type FilterMatchArray = FilterMatchArraySingle | FilterMatchArrayMultiple\nexport type FilterMatch = boolean | number | FilterMatchArray\nexport type FilterFunction = (value: string, query: string, item?: InternalItem) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\nexport interface InternalItem<T = any> {\n  value: any\n  raw: T\n  type?: string\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n  if (!query.length) return 0\n\n  value = value.toString().toLocaleLowerCase()\n  query = query.toString().toLocaleLowerCase()\n\n  const result = []\n  let idx = value.indexOf(query)\n  while (~idx) {\n    result.push([idx, idx + query.length] as const)\n\n    idx = value.indexOf(query, idx + query.length)\n  }\n\n  return result.length ? result : -1\n}\n\nfunction normaliseMatch (match: FilterMatch, query: string): FilterMatchArrayMultiple | undefined {\n  if (match == null || typeof match === 'boolean' || match === -1) return\n  if (typeof match === 'number') return [[match, match + query.length]]\n  if (Array.isArray(match[0])) return match as FilterMatchArrayMultiple\n  return [match] as FilterMatchArrayMultiple\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\nexport function filterItems (\n  items: readonly (readonly [item: InternalItem, transformed: {}])[] | readonly InternalItem[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: { index: number, matches: Record<string, FilterMatchArrayMultiple | undefined> }[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  loop:\n  for (let i = 0; i < items.length; i++) {\n    const [item, transformed = item] = wrapInArray(items[i]) as readonly [InternalItem, {}]\n    const customMatches: Record<string, FilterMatchArrayMultiple | undefined> = {}\n    const defaultMatches: Record<string, FilterMatchArrayMultiple | undefined> = {}\n    let match: FilterMatch = -1\n\n    if ((query || customFiltersLength > 0) && !options?.noFilter) {\n      if (typeof item === 'object') {\n        if (item.type === 'divider' || item.type === 'subheader') {\n          continue\n        }\n\n        const filterKeys = keys || Object.keys(transformed)\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(transformed, key)\n          const keyFilter = options?.customKeyFilter?.[key]\n\n          match = keyFilter\n            ? keyFilter(value, query, item)\n            : filter(value, query, item)\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = normaliseMatch(match, query)\n            else defaultMatches[key] = normaliseMatch(match, query)\n          } else if (options?.filterMode === 'every') {\n            continue loop\n          }\n        }\n      } else {\n        match = filter(item, query, item)\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = normaliseMatch(match, query)\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          !defaultMatchesLength\n        )\n      ) continue\n    }\n\n    array.push({ index: i, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter <T extends InternalItem> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query: Ref<string | undefined> | (() => string | undefined),\n  options?: {\n    transform?: (item: T) => {}\n    customKeyFilter?: MaybeRef<FilterKeyFunctions | undefined>\n  }\n) {\n  const filteredItems = shallowRef<T[]>([])\n  const filteredMatches = shallowRef(new Map<unknown, Record<string, FilterMatchArrayMultiple | undefined>>())\n  const transformedItems = computed(() => (\n    options?.transform\n      ? unref(items).map(item => ([item, options.transform!(item)] as const))\n      : unref(items)\n  ))\n\n  watchEffect(() => {\n    const _query = typeof query === 'function' ? query() : unref(query)\n    const strQuery = (\n      typeof _query !== 'string' &&\n      typeof _query !== 'number'\n    ) ? '' : String(_query)\n\n    const results = filterItems(\n      transformedItems.value,\n      strQuery,\n      {\n        customKeyFilter: {\n          ...props.customKeyFilter,\n          ...unref(options?.customKeyFilter),\n        },\n        default: props.customFilter,\n        filterKeys: props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n\n    const originalItems = unref(items)\n\n    const _filteredItems: typeof filteredItems['value'] = []\n    const _filteredMatches: typeof filteredMatches['value'] = new Map()\n    results.forEach(({ index, matches }) => {\n      const item = originalItems[index]\n      _filteredItems.push(item)\n      _filteredMatches.set(item.value, matches)\n    })\n    filteredItems.value = _filteredItems\n    filteredMatches.value = _filteredMatches\n  })\n\n  function getMatches (item: T) {\n    return filteredMatches.value.get(item.value)\n  }\n\n  return { filteredItems, filteredMatches, getMatches }\n}\n\nexport function highlightResult (name: string, text: string, matches: FilterMatchArrayMultiple | undefined) {\n  if (matches == null || !matches.length) return text\n\n  return matches.map((match, i) => {\n    const start = i === 0 ? 0 : matches[i - 1][1]\n    const result = [\n      <span class={ `${name}__unmask` }>{ text.slice(start, match[0]) }</span>,\n      <span class={ `${name}__mask` }>{ text.slice(match[0], match[1]) }</span>,\n    ]\n    if (i === matches.length - 1) {\n      result.push(<span class={ `${name}__unmask` }>{ text.slice(match[1]) }</span>)\n    }\n    return <>{ result }</>\n  })\n}\n"],
  "mappings": "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",
  "names": ["defaultFilter", "value", "query", "item", "length", "toString", "toLocaleLowerCase", "result", "idx", "indexOf", "push", "normaliseMatch", "match", "Array", "isArray", "makeFilterProps", "propsFactory", "customFilter", "Function", "customKeyFilter", "Object", "filterKeys", "String", "filterMode", "type", "default", "noFilter", "Boolean", "filterItems", "items", "options", "array", "filter", "keys", "wrapInArray", "customFiltersLength", "loop", "i", "transformed", "customMatches", "defaultMatches", "key", "getPropertyFromItem", "keyFilter", "title", "defaultMatchesLength", "customMatchesLength", "index", "matches", "useFilter", "props", "filteredItems", "shallowRef", "filteredMatches", "Map", "transformedItems", "computed", "transform", "unref", "map", "watchEffect", "_query", "strQuery", "results", "originalItems", "_filteredItems", "_filteredMatches", "forEach", "_ref", "set", "getMatches", "get", "highlightResult", "name", "text", "start", "_createElementVNode", "_normalizeClass", "slice", "_Fragment"]
}
